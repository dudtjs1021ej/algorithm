## 📒 배열 

- 조회는 항상 `O(1)`
- 파이썬에선 `list` 가 동적 배열(크기 지정 안해도 o)
- `enumerate()` : 인덱스와 값을 같이 리턴



## 📒 연결 리스트

- 선형 자료구조
- 탐색에는 `O(n)` 
- 시작이나 끝에 아이템 추가, 삭제 추출 `O(1)`
- `list` 보다는 이중 연결 리스트 구조인  `deque` 이 더 빠름 (`O(1)`)

```python
deque = collections.deque() #덱 선언
...
if q.popleft() != q.pop() #팰린드롬 문제에서 덱의 사용
```



## 📒 스택, 큐

- `stack` : LIFO (후입선출) / `push`, `pop`
- `queue` : FIFO (선입선출)



## 📒 데크, 우선순위 큐

- __데크__
  - 양쪽 끝을 모두 추출할 수 있는, 큐를 일반화한 형태의 추상 자료형
  - 이중 연결 리스트로 구현
  - `collections.deque()`
- __우선순위 큐__

  - 특정 조건에 따라 우선순위가 가장 높은 요소가 추출되는 자료형
  - 정렬 알고리즘 사용 -> __우선순위 큐__를 만들 수 있음
  - `heapq` 모듈 사용 




## 📒 해시 테이블

- 키를 값에 매핑할 수 있는 구조

- 시간복잡도 대부분 `O(1)` -> 빠른 성능

- __충돌__은 무조건 발생 -> 해결하는 방법 2가지

   1. __개별 체이닝__
      - 충돌 발생 시, 같은 인덱스들을 __연결 리스트__로 연결하는 방식
  2. __오픈 어드레싱__
     - 충돌 발생 시, __빈 공간__을 찾아나서는 방식
     - 모든 원소가 반드시 자신의 해시값과 일치한다는 보장x
  
- 해시 테이블로 구현된 파이썬의 자료형? -> `딕셔너리`

- `딕셔너리`는 __오픈 어드레싱__ 방식 사용